"""time unwrapping algorithm"""import timefrom binkoala import read_bin_noconvimport numpy as npfrom math import infimport osfrom os import listdirimport h5pyimport platformfrom access_data import get_sequencefrom get_num_bins import get_num_binsfrom skimage.restoration import unwrap_phasefrom calibrate_surface import fit_surface# time unwrapping: sequence informationseq_id, exp_type, data_file_postfix = '10122021A_bc', 'wave_pool', '_cal_ski_fullROI'# calibration: sequence informationcalibrate_data = Truecal_seq_id, cal_exp_type = seq_id, exp_typecal_frames = np.arange(100)# unwrap with 'koala' or 'not_koala' (i.e., skimage)unwrap_method = 'not_koala'# temporal unwrapping roi (set to None for ROI = entire frame)# ROI = [385,415,385,415]ROI = None# portion of sequence to extract (cutoff: 'time' or 'frame')cutoff = 'frame'init_time, final_time = 0, infinit_frame, final_frame = 0, 10000# set os path definitionsif platform.system() == 'Darwin':    root, cd = '/Volumes/atom_library', '/'elif platform.system() == 'Windows':    root, cd = 'Z:', '\\'# main workding directoryseq_dir = root + cd + exp_type + cd + seq_id + cd# get time and frame vectorst, frames = get_sequence(seq_id,exp_type,cutoff=cutoff,init_time=init_time,final_time=final_time, \                         init_frame=init_frame,final_frame=final_frame)# dir for reconstruction w/o offsetrecon_dir = seq_dir + 'offset_removed' + cd# input image directoriesrecon_phwrap_dir = recon_dir + 'Phase' + cd + 'Float' + cd + 'Bin' + cdrecon_phunwrap_dir = recon_dir + 'UnwrappedPhase' + cd + 'Float' + cd + 'Bin' + cd# initial console outputprint('')print('initializing time unwrapping and data file storage for sequence: {0}'.format(seq_id))print('unwrapping: {0:.2f}s (frame {1:d}) to {2:.2f}s (frame {3:d})'.format(t[0],frames[0],t[-1],frames[-1]))print('phase unwrapping with method: {0}'.format(unwrap_method))if calibrate_data:    print('calibration: on')else:    print('calibration: off')if ROI is None:    print('roi: entire image')else:    print('roi: x = {0:d} to {1:d}, y = {2:d} to {3:d}'.format(ROI[0],ROI[1],ROI[2],ROI[3]))print('')# get calibration surfaceif calibrate_data:    print('getting calibration surface...')    # set paths    cal_dir = root + cd + cal_exp_type + cd + cal_seq_id + cd + 'offset_removed' + cd    if unwrap_method == 'koala':        cal_frames_dir = cal_dir + 'UnwrappedPhase' + cd + 'Float' + cd + 'Bin' + cd    elif unwrap_method == 'not_koala':        cal_frames_dir = cal_dir + 'Phase' + cd + 'Float' + cd + 'Bin' + cd    for k,frame in enumerate(cal_frames):        # read in initial reference phase image and sequence header data        ph_f = cal_frames_dir + str(frame).zfill(5) + '_phase.bin'        if k == 0:            # header info            ph, header = read_bin_noconv(ph_f)            w = (int)(header["width"])            h = (int)(header["height"])            px_size = (float)(header["px_size"])            hconv = (float)(header["hconv"])            unit_code = (int)(header["unit_code"])            # preallocate and store            cal_set = np.empty((w,h,len(cal_frames)))        elif k > 0:            # read in initial reference phase image and sequence header data            ph, _ = read_bin_noconv(ph_f)        # unwrap as needed        if unwrap_method == 'not_koala':            ph = np.pi*unwrap_phase(ph)        cal_set[:,:,k] = ph    # get mean and calibration fit    cal_mean = np.mean(cal_set,axis=2)    ph_cal, _, _ = fit_surface(cal_mean)    # initialze midpoint to zero    ph_cal = ph_cal - np.mean(ph_cal)    print('... calibration surface complete')    print('')# time unwrapping algorithm, iterate through files in file listfor k, frame in enumerate(frames):    # initialization step, define first image in unwrapped sequence as "zero" displacement    if k == 0:        # print update        print('unwrapping data...')        # start timer        start_timer = time.time()        # read in initial reference phase image and sequence header data        ph_wr_f = recon_phwrap_dir + str(frame).zfill(5) + '_phase.bin'        ph_wr_in, header = read_bin_noconv(ph_wr_f)        w = (int)(header["width"])        h = (int)(header["height"])        px_size = (float)(header["px_size"])        hconv = (float)(header["hconv"])        unit_code = (int)(header["unit_code"])        # mesh vectors        x = np.arange(w)*px_size*10**6        y = np.arange(h)*px_size*10**6        # get unwrapped image, calibrate        if unwrap_method == 'koala':            ph_unw_f = recon_phunwrap_dir + str(frame).zfill(5) + '_phase.bin'            ph_unw_in, _ = read_bin_noconv(ph_unw_f)        elif unwrap_method == 'not_koala':            ph_unw_in = np.pi*unwrap_phase(ph_wr_in)        # initialize time unwrapping with mean of first frame set to zero, calibrate        if not calibrate_data:            ph_cal = np.zeros(np.shape(ph_unw_in))        ph_unw_in -= (np.mean(ph_unw_in)+calibrate_data*ph_cal)        # create hdf file        data_file_path = seq_dir + seq_id + '_data' + data_file_postfix + '.hdf5'        data_file = h5py.File(data_file_path,'w')        # create data groups        meta_data = data_file.create_group('meta')        main_data = data_file.create_group('main')        # add metadata information        meta_data.attrs['x_units'] = 'microns'        meta_data.attrs['y_units'] = 'microns'        meta_data.attrs['z_units'] = 'microns'        meta_data.attrs['t_units'] = 'seconds'        # add metadata        meta_data.create_dataset('x',(len(x),),dtype='f',data=x)        meta_data.create_dataset('y',(len(y),),dtype='f',data=y)        meta_data.create_dataset('t',(len(t),),dtype='f',data=t)        meta_data.create_dataset('frames',(len(frames),),dtype='i',data=frames)        # add data to hdf file        Z = ph_unw_in*hconv*10**6        main_data.create_dataset(str(frame).zfill(5),(len(x),len(y)),dtype='f',data=Z)    # simple difference update with histogram-based denoised correction (see tristan's 02/24/2021 slide set)    if k > 0:        # unwrapped image from simple difference of wrapped phase images (with offset previously removed)        fname = recon_phwrap_dir + str(frame).zfill(5) + '_phase.bin'        ph_wr_new, header = read_bin_noconv(fname)        # simple difference (ph_new and ph_in cannot displace "too much" between time steps for this to work)        ph_diff = np.angle(np.exp(complex(0.,1.)*(ph_wr_new-ph_wr_in)))        ph_unw_from_diff = ph_unw_in + ph_diff        # get unwrapped image, calibrate        if unwrap_method == 'koala':            ph_unw_f = recon_phunwrap_dir + str(frame).zfill(5) + '_phase.bin'            ph_unw_direct, _ = read_bin_noconv(ph_unw_f)        elif unwrap_method == 'not_koala':            ph_unw_direct = np.pi*unwrap_phase(ph_wr_new)        if calibrate_data:            ph_unw_direct -= ph_cal        # offset between direct and indirect methods over roi        if ROI is None:            z = ph_unw_direct-ph_unw_from_diff        else:            z = ph_unw_direct[ROI[0]:ROI[1],ROI[2]:ROI[3]]-ph_unw_from_diff[ROI[0]:ROI[1],ROI[2]:ROI[3]]        # measure offset using the mode of the histogram (rather than mean, median), better for noisy images        num_bins = 1000        hist = np.histogram(z,bins=num_bins,range=(np.min(z),np.max(z)))        index = np.argmax(hist[0])        offset_value = hist[1][index]            # check for narrow deviation with a 2pi positive shift of negatively offset pixels        s = np.std(z)        signmap = (z < 0).astype(float)*2.*np.pi        z2 = z + signmap        s2 = np.std(z2)        if (s2 < s - 0.05):            num_bins = 1000            hist = np.histogram(z2,bins=num_bins, range=(np.min(z2),np.max(z2)))            index = np.argmax(hist[0])            offset_value = hist[1][index]                # apply offset to correct directly unwrapped phase image        ph_out = ph_unw_direct-offset_value        # reset variables for next iteration        ph_wr_in = ph_wr_new        ph_unw_in = ph_out        # convert and store result        Z = ph_out*hconv*10**6        main_data.create_dataset(str(frame).zfill(5),(len(x),len(y)),dtype='f',data=Z)        # show percent complete        if (k % round(0.05*len(frames)) == 0.0) & (k > 0):            print('{0:d}% complete in {1:.1f} minutes'.format(round(100*k/len(frames)),(time.time()-start_timer)/60))# end temporal unwrapping timer, print total unwrapping timetime_process_min = round((time.time()-start_timer)/60)print('')print("temporal unwrapping completed and data stored in {0:.1f} minutes for sequence: {1}".format(time_process_min,seq_id))print('')        